
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zenith AI Particle System</title>
    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background: #050505; color: white; font-family: sans-serif; cursor: crosshair; }
        #root { width: 100vw; height: 100vh; }
        canvas { touch-action: none; }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; }
    </style>

    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.2.3",
    "react-dom": "https://esm.sh/react-dom@19.2.3",
    "react-dom/client": "https://esm.sh/react-dom@19.2.3/client",
    "three": "https://esm.sh/three@0.182.0",
    "three/examples/jsm/postprocessing/EffectComposer": "https://esm.sh/three@0.182.0/examples/jsm/postprocessing/EffectComposer",
    "three/examples/jsm/postprocessing/RenderPass": "https://esm.sh/three@0.182.0/examples/jsm/postprocessing/RenderPass",
    "three/examples/jsm/postprocessing/UnrealBloomPass": "https://esm.sh/three@0.182.0/examples/jsm/postprocessing/UnrealBloomPass",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "three/": "https://esm.sh/three@^0.182.0/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useEffect, useRef, useState } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';

        // --- Constants & Types ---
        const ShapeType = {
          HEART: 'Heart',
          FLOWER: 'Flower',
          STAR: 'Star',
          TREE: 'Christmas Tree',
          BUDDHA: 'Sphere (Zen)',
          FIREWORKS: 'Fireworks'
        };

        const THEME = {
          MATTE_GREEN: '#2F5233',
          METALLIC_GOLD: '#D4AF37',
          XMAS_RED: '#C41E3A',
          BLACK: '#050505',
          EMERALD: '#50C878'
        };

        const PARTICLE_COUNT = 8000;
        const ORNAMENT_COUNT = 1280;

        const generateShapePositions = (type, count) => {
          const positions = new Float32Array(count * 3);
          for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            let x = 0, y = 0, z = 0;

            switch (type) {
              case ShapeType.HEART: {
                const t = Math.random() * Math.PI * 2;
                x = 16 * Math.pow(Math.sin(t), 3);
                y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
                z = (Math.random() - 0.5) * 5;
                const scale = 0.5; x *= scale; y *= scale; z *= scale;
                break;
              }
              case ShapeType.STAR: {
                const t = Math.random() * Math.PI * 2;
                const r = (i % 2 === 0 ? 10 : 4) + (Math.random() - 0.5) * 2;
                x = Math.cos(t) * r; y = Math.sin(t) * r; z = (Math.random() - 0.5) * 4;
                break;
              }
              case ShapeType.TREE: {
                let h = Math.random() * 20; if (h < 0.6) h = 0;
                const angle = Math.random() * Math.PI * 2;
                const r = (20 - h) * 0.4;
                x = Math.cos(angle) * r; y = h - 10; z = Math.sin(angle) * r;
                const jitterScale = Math.min(1.0, h / 2.0);
                x += (Math.random() - 0.5) * 1.5 * jitterScale;
                z += (Math.random() - 0.5) * 1.5 * jitterScale;
                break;
              }
              case ShapeType.BUDDHA: {
                const phi = Math.acos(-1 + (2 * i) / count);
                const theta = Math.sqrt(count * Math.PI) * phi;
                const noise = Math.sin(phi * 4) * Math.cos(theta * 3) * 0.4 + 
                              Math.sin(phi * 2.5) * Math.sin(theta * 5) * 0.3 + 
                              Math.cos(phi * 6) * 0.2;
                const radius = 10 * (1 + noise) * (0.8 + Math.random() * 0.4);
                x = radius * Math.cos(theta) * Math.sin(phi);
                y = radius * Math.sin(theta) * Math.sin(phi);
                z = radius * Math.cos(phi);
                break;
              }
              case ShapeType.FLOWER: {
                const t = Math.random() * Math.PI * 2;
                const petals = 5; const r = 8 * Math.cos(petals * t);
                x = r * Math.cos(t); y = r * Math.sin(t); z = (Math.random() - 0.5) * 3;
                break;
              }
              case ShapeType.FIREWORKS: {
                const radius = Math.random() * 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                x = radius * Math.sin(phi) * Math.cos(theta);
                y = radius * Math.sin(phi) * Math.sin(theta);
                z = radius * Math.cos(phi);
                break;
              }
            }
            positions[i3] = x; positions[i3 + 1] = y; positions[i3 + 2] = z;
          }
          return positions;
        };

        // --- Gesture Service ---
        class GestureService {
          constructor() {
            this.hands = new Hands({
              locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            this.hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            this.hands.onResults(this.processResults.bind(this));
          }
          async start(videoElement, callback) {
            this.onResultsCallback = callback;
            this.camera = new Camera(videoElement, {
              onFrame: async () => { await this.hands.send({ image: videoElement }); },
              width: 640, height: 480
            });
            return this.camera.start();
          }
          processResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
              this.onResultsCallback(null); return;
            }
            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];
            const tips = [4, 8, 12, 16, 20].map(idx => landmarks[idx]);
            let totalDist = 0;
            tips.forEach(tip => {
              totalDist += Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
            });
            const avgDist = totalDist / 5;
            const openness = Math.min(Math.max((avgDist - 0.1) / 0.35, 0), 1);
            const thumbTip = landmarks[4]; const indexTip = landmarks[8];
            const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
            const isPinching = pinchDist < 0.05;
            const middleBase = landmarks[9];
            const dx = middleBase.x - wrist.x; const dy = middleBase.y - wrist.y;
            this.onResultsCallback({
              openness,
              rotation: { x: dy * 2, y: -dx * 2, z: Math.atan2(dy, dx) },
              isPinching,
              pinchStrength: Math.min(Math.max(1 - (pinchDist / 0.1), 0), 1),
              center: { x: middleBase.x, y: middleBase.y }
            });
          }
        }

        // --- Scene Service ---
        class SceneService {
          constructor(container) {
            this.scene = new THREE.Scene();
            this.scene.background = new THREE.Color(THEME.BLACK);
            this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            this.camera.position.z = 40;
            this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(this.renderer.domElement);

            this.composer = new EffectComposer(this.renderer);
            this.composer.addPass(new RenderPass(this.scene, this.camera));
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.1, 0.6, 0.45);
            this.composer.addPass(bloomPass);

            this.geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            for(let i=0; i<PARTICLE_COUNT*3; i++) positions[i] = (Math.random() - 0.5) * 100;
            this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            this.material = new THREE.PointsMaterial({
              color: new THREE.Color(THEME.METALLIC_GOLD),
              size: 0.1, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, opacity: 0.5
            });
            this.particles = new THREE.Points(this.geometry, this.material);
            this.scene.add(this.particles);

            this.ornaments = new THREE.Group();
            this.scene.add(this.ornaments);
            this.ornamentObjects = [];
            this.ornamentTargets = [];
            this.zenOrnamentTargets = [];
            
            this.currentShape = ShapeType.TREE;
            this.targetPositions = generateShapePositions(this.currentShape, PARTICLE_COUNT);
            this.zenParticlePositions = generateShapePositions(ShapeType.BUDDHA, PARTICLE_COUNT);
            this.expansionFactor = 1.0;
            this.isZenMode = false;
            this.targetRotation = new THREE.Euler();
            this.clock = new THREE.Clock();

            this.initOrnaments();
            window.addEventListener('resize', this.onResize.bind(this));
            this.animate();
          }

          onResize() {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.composer.setSize(window.innerWidth, window.innerHeight);
          }

          toggleZenMode() { this.isZenMode = !this.isZenMode; }

          initOrnaments() {
            const minDistance = 2.2;
            for (let i = 0; i < ORNAMENT_COUNT; i++) {
              let ornament;
              let pos = new THREE.Vector3();
              let valid = false;
              let attempts = 0;
              while (!valid && attempts < 1000) {
                let h = 20 * (1 - Math.sqrt(Math.random())); if (h < 1.2) h = 0;
                const angle = Math.random() * Math.PI * 2; const r = Math.sqrt(Math.random()) * ((20 - h) * 0.38);
                pos.set(Math.cos(angle) * r, h - 10, Math.sin(angle) * r);
                valid = !this.ornamentTargets.some(t => pos.distanceTo(t) < minDistance);
                attempts++;
              }
              if (!valid) continue;

              const u = Math.random(); const v = Math.random();
              const theta = 2 * Math.PI * u; const phi = Math.acos(2 * v - 1);
              const noise = Math.sin(phi * 4) * Math.cos(theta * 3) * 0.4 + Math.sin(phi * 2.5) * Math.sin(theta * 5) * 0.3;
              const r_vol = 10 * (1 + noise) * Math.pow(Math.random(), 1/3);
              this.zenOrnamentTargets.push(new THREE.Vector3(r_vol * Math.sin(phi) * Math.cos(theta), r_vol * Math.sin(phi) * Math.sin(theta), r_vol * Math.cos(phi)));

              const randType = Math.random();
              if (randType < 0.25) ornament = this.createDetailedGingerbread();
              else if (randType < 0.5) ornament = this.createStocking();
              else if (randType < 0.75) ornament = this.createGiftBox();
              else ornament = this.createBow();

              this.ornamentTargets.push(pos);
              ornament.position.copy(pos);
              ornament.scale.set(0, 0, 0);
              ornament.userData = { 
                baseScale: (1.0 + Math.random() * 0.4) * 1.5, 
                floatOffset: Math.random() * Math.PI * 2, floatSpeed: 0.2 + Math.random() * 0.5, 
                floatRadius: 2.5 + Math.random() * 4.0, rotationSpeed: (Math.random() - 0.5) * 0.02 
              };
              this.ornamentObjects.push(ornament);
              this.ornaments.add(ornament);
            }
            this.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const key = new THREE.DirectionalLight(0xffffff, 1.6); key.position.set(50, 50, 50); this.scene.add(key);
          }

          createStocking() {
            const group = new THREE.Group();
            const redMat = new THREE.MeshStandardMaterial({ color: THEME.XMAS_RED, roughness: 1.0 });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1.0 });
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.6, 16), redMat);
            leg.position.y = 0.3; group.add(leg);
            const foot = new THREE.Mesh(new THREE.CapsuleGeometry(0.2, 0.3, 8, 16), redMat);
            foot.rotation.z = Math.PI / 2.5; foot.position.set(0.15, 0, 0); group.add(foot);
            const cuff = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.08, 12, 24), whiteMat);
            cuff.rotation.x = Math.PI / 2; cuff.position.y = 0.6; group.add(cuff);
            return group;
          }

          createBow() {
            const group = new THREE.Group();
            const color = Math.random() > 0.3 ? THEME.XMAS_RED : THEME.METALLIC_GOLD;
            const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.4, metalness: 0.3 });
            const loopGeo = new THREE.TorusGeometry(0.18, 0.06, 8, 16);
            const l = new THREE.Mesh(loopGeo, mat); l.scale.set(1.4, 0.8, 1); l.position.set(-0.2, 0.1, 0); l.rotation.z = Math.PI / 6; group.add(l);
            const r = new THREE.Mesh(loopGeo, mat); r.scale.set(1.4, 0.8, 1); r.position.set(0.2, 0.1, 0); r.rotation.z = -Math.PI / 6; group.add(r);
            const knot = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), mat); knot.position.set(0, 0.1, 0.05); group.add(knot);
            return group;
          }

          createDetailedGingerbread() {
            const group = new THREE.Group();
            const brownMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const candyMat = new THREE.MeshStandardMaterial({ color: THEME.XMAS_RED, emissive: THEME.XMAS_RED, emissiveIntensity: 0.5 });
            const pinkMat = new THREE.MeshStandardMaterial({ color: 0xffb6c1, roughness: 1.0 });
            
            const shape = new THREE.Shape();
            shape.absarc(0, 0.9, 0.25, 0, Math.PI * 2, false); 
            shape.moveTo(-0.1, 0.7); shape.lineTo(-0.45, 0.6); shape.lineTo(-0.45, 0.4); shape.lineTo(-0.15, 0.5); shape.lineTo(-0.35, 0.0);
            shape.lineTo(-0.1, 0.0); shape.lineTo(0, 0.3); shape.lineTo(0.1, 0.0); shape.lineTo(0.35, 0.0); shape.lineTo(0.15, 0.5);
            shape.lineTo(0.45, 0.4); shape.lineTo(0.45, 0.6); shape.lineTo(0.1, 0.7);
            const man = new THREE.Mesh(new THREE.ExtrudeGeometry(shape, { depth: 0.18, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05 }), brownMat);
            man.rotation.x = Math.PI; man.rotation.z = Math.PI; man.position.z = 0.09; group.add(man);

            // Eyes & Smile
            const eyeGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const eyeL = new THREE.Mesh(eyeGeo, whiteMat); eyeL.position.set(-0.08, 0.9, 0.18); group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, whiteMat); eyeR.position.set(0.08, 0.9, 0.18); group.add(eyeR);
            const smileGeo = new THREE.TorusGeometry(0.08, 0.015, 8, 12, Math.PI);
            const smile = new THREE.Mesh(smileGeo, whiteMat); smile.rotation.x = -Math.PI/1.1; smile.position.set(0, 0.85, 0.18); group.add(smile);
            
            // Rosy cheeks
            const cheekL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), pinkMat); cheekL.position.set(-0.16, 0.85, 0.17); group.add(cheekL);
            const cheekR = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), pinkMat); cheekR.position.set(0.16, 0.85, 0.17); group.add(cheekR);

            // Buttons & icing
            const b1 = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 8), candyMat); b1.position.set(0, 0.6, 0.18); group.add(b1);
            const icingGeo = new THREE.CapsuleGeometry(0.015, 0.12, 4, 8);
            const icingLegL = new THREE.Mesh(icingGeo, whiteMat); icingLegL.position.set(-0.25, 0.1, 0.18); icingLegL.rotation.z = 0.9; group.add(icingLegL);
            const icingLegR = new THREE.Mesh(icingGeo, whiteMat); icingLegR.position.set(0.25, 0.1, 0.18); icingLegR.rotation.z = -0.9; group.add(icingLegR);

            return group;
          }

          createGiftBox() {
            const group = new THREE.Group();
            const boxColor = Math.random() > 0.5 ? THEME.XMAS_RED : THEME.METALLIC_GOLD;
            const ribColor = boxColor === THEME.XMAS_RED ? THEME.METALLIC_GOLD : THEME.XMAS_RED;
            const boxMat = new THREE.MeshStandardMaterial({ color: boxColor, roughness: 0.4 });
            const lidMat = new THREE.MeshStandardMaterial({ color: boxColor, roughness: 0.3, metalness: 0.2 });
            const ribMat = new THREE.MeshStandardMaterial({ color: ribColor, roughness: 0.2, metalness: 0.8 });
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const base = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.35, 0.42), boxMat); base.position.y = 0.175; group.add(base);
            const lid = new THREE.Mesh(new THREE.BoxGeometry(0.46, 0.12, 0.46), lidMat); lid.position.y = 0.4; group.add(lid);
            
            // Polka dots decoration
            for(let i=0; i<6; i++) {
                const dot = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 8), whiteMat);
                dot.position.set((Math.random()-0.5)*0.4, Math.random()*0.3, 0.22); group.add(dot);
            }

            const rib1 = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.48, 0.43), ribMat); rib1.position.y = 0.24; group.add(rib1);
            const bow = new THREE.Mesh(new THREE.TorusGeometry(0.12, 0.02, 12, 24), ribMat); bow.position.y = 0.5; bow.rotation.x = Math.PI/2; group.add(bow);
            
            return group;
          }

          updateConfig(c) {
            if (c.color) this.material.color.set(c.color);
            if (c.shape) {
              this.currentShape = c.shape;
              this.targetPositions = generateShapePositions(this.currentShape, PARTICLE_COUNT);
              this.material.color.set(this.currentShape === ShapeType.TREE ? THEME.MATTE_GREEN : (c.color || THEME.METALLIC_GOLD));
            }
          }

          updateGestures(g) {
            if (!g) { this.expansionFactor = THREE.MathUtils.lerp(this.expansionFactor, 1.0, 0.05); return; }
            this.expansionFactor = THREE.MathUtils.lerp(this.expansionFactor, 0.2 + (g.openness * 1.5), 0.1);
            this.targetRotation.y = g.rotation.y * 2.0; this.targetRotation.x = g.rotation.x * 2.0;
            this.camera.position.z = THREE.MathUtils.lerp(this.camera.position.z, g.isPinching ? 15 : 40, 0.05);
          }

          animate() {
            requestAnimationFrame(this.animate.bind(this));
            const t = this.clock.getElapsedTime();
            this.particles.rotation.y = THREE.MathUtils.lerp(this.particles.rotation.y, this.targetRotation.y, 0.05);
            this.particles.rotation.x = THREE.MathUtils.lerp(this.particles.rotation.x, this.targetRotation.x, 0.05);
            this.ornaments.rotation.copy(this.particles.rotation);
            const pos = this.geometry.attributes.position;
            const targets = this.isZenMode ? this.zenParticlePositions : this.targetPositions;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
              const i3 = i * 3;
              let tx = targets[i3] * this.expansionFactor, ty = targets[i3+1] * this.expansionFactor, tz = targets[i3+2] * this.expansionFactor;
              if (this.isZenMode) { const p = 1.0 + Math.sin(t * 0.4 + i * 0.005) * 0.05; tx *= p; ty *= p; tz *= p; }
              pos.array[i3] = THREE.MathUtils.lerp(pos.array[i3], tx, 0.05);
              pos.array[i3+1] = THREE.MathUtils.lerp(pos.array[i3+1], ty, 0.05);
              pos.array[i3+2] = THREE.MathUtils.lerp(pos.array[i3+2], tz, 0.05);
            }
            pos.needsUpdate = true;
            const isTree = this.currentShape === ShapeType.TREE;
            this.ornamentObjects.forEach((obj, i) => {
              const vis = (isTree || this.isZenMode);
              const s = vis ? (obj.userData.baseScale * this.expansionFactor) : 0.0;
              obj.scale.lerp(new THREE.Vector3(s, s, s), 0.05);
              if (vis) {
                let tp = this.isZenMode ? this.zenOrnamentTargets[i].clone().multiplyScalar(this.expansionFactor).add(new THREE.Vector3(Math.sin(t*obj.userData.floatSpeed)*obj.userData.floatRadius, Math.cos(t*obj.userData.floatSpeed)*obj.userData.floatRadius, 0)) : this.ornamentTargets[i].clone().multiplyScalar(this.expansionFactor);
                obj.position.lerp(tp, 0.05);
              }
            });
            this.composer.render();
          }
        }

        // --- App Component ---
        const App = () => {
          const containerRef = useRef(null);
          const sceneRef = useRef(null);
          const gestureRef = useRef(null);
          const videoRef = useRef(null);
          const [gestureState, setGestureState] = useState(null);
          const [isCameraActive, setIsCameraActive] = useState(false);
          const [manualOpenness, setManualOpenness] = useState(1.0);
          const [config, setConfig] = useState({ shape: ShapeType.TREE, color: THEME.METALLIC_GOLD });

          useEffect(() => {
            const scene = new SceneService(containerRef.current);
            sceneRef.current = scene;
            const handleMove = (e) => {
              if (isCameraActive) return;
              const g = { openness: manualOpenness, rotation: { x: (e.clientY/window.innerHeight-0.5)*0.5, y: (e.clientX/window.innerWidth-0.5)*0.5, z: 0 }, isPinching: false, pinchStrength: 0, center: { x: e.clientX/window.innerWidth, y: e.clientY/window.innerHeight } };
              setGestureState(g); scene.updateGestures(g);
            };
            const handleDown = (e) => { if (e.button === 0) scene.toggleZenMode(); };
            window.addEventListener('mousemove', handleMove); window.addEventListener('mousedown', handleDown);
            return () => { window.removeEventListener('mousemove', handleMove); window.removeEventListener('mousedown', handleDown); };
          }, [isCameraActive, manualOpenness]);

          const startCamera = async () => {
            gestureRef.current = new GestureService();
            await gestureRef.current.start(videoRef.current, (s) => { setGestureState(s); sceneRef.current?.updateGestures(s); });
            setIsCameraActive(true);
          };

          const getShapeIcon = (s) => {
            switch(s) {
              case ShapeType.HEART: return '‚ù§Ô∏è'; case ShapeType.FLOWER: return 'üå∏'; case ShapeType.STAR: return '‚≠ê';
              case ShapeType.TREE: return 'üéÑ'; case ShapeType.BUDDHA: return '‚ö™'; case ShapeType.FIREWORKS: return 'üéÜ';
              default: return '‚óè';
            }
          };

          return (
            <div className="relative w-full h-full overflow-hidden bg-[#050505] text-white">
              <div ref={containerRef} className="absolute inset-0 z-0" />
              <video ref={videoRef} className="hidden" playsInline muted />
              <div className="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-6">
                <header className="flex flex-col items-center gap-4 pointer-events-auto">
                  <div className="flex flex-wrap justify-center gap-2 p-1.5 bg-white/5 backdrop-blur-3xl rounded-full border border-white/10 shadow-2xl">
                    {Object.values(ShapeType).map((s) => (
                      <button key={s} onClick={() => { setConfig({...config, shape: s}); sceneRef.current.updateConfig({shape: s}); }}
                        className={`w-12 h-12 rounded-full text-xl flex items-center justify-center transition-all ${config.shape === s ? 'bg-yellow-500 shadow-lg scale-110' : 'hover:bg-white/10'}`}>
                        {getShapeIcon(s)}
                      </button>
                    ))}
                  </div>
                  <div className="flex gap-3">
                    {!isCameraActive && <button onClick={startCamera} className="px-5 py-2 bg-yellow-500 text-black font-black text-[9px] rounded-full shadow-xl">üì∑</button>}
                    <button onClick={() => document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen()} className="w-9 h-9 flex items-center justify-center bg-white/5 border border-white/10 rounded-full">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" /></svg>
                    </button>
                  </div>
                </header>

                <footer className="flex justify-end pointer-events-auto">
                  <div className="w-48 p-4 bg-white/5 backdrop-blur-3xl rounded-[1.2rem] border border-white/10 shadow-2xl space-y-3">
                    <div>
                      <div className="flex justify-between items-center mb-1.5"><label className="text-[7px] font-black">üé®</label><span className="text-[7px] text-yellow-500 font-mono">{config.color}</span></div>
                      <div className="relative h-4 w-full overflow-hidden rounded-sm"><input type="color" value={config.color} onChange={(e) => { setConfig({...config, color: e.target.value}); sceneRef.current.updateConfig({color: e.target.value}); }} className="absolute -inset-1 w-[120%] h-[120%] bg-transparent cursor-pointer border-none" /></div>
                    </div>
                    <div className="grid grid-cols-2 gap-1.5">
                      <div className="p-2 bg-white/5 rounded-lg border border-white/10 text-center"><span className="text-[9px]">‚ú®</span></div>
                      <div className="p-2 bg-white/5 rounded-lg border border-white/10 text-center"><span className="text-[9px]">{isCameraActive ? 'üñêÔ∏è' : 'üñ±Ô∏è'}</span></div>
                    </div>
                  </div>
                </footer>
              </div>
              {isCameraActive && (
                <div className="absolute top-24 right-8 w-32 h-24 bg-black/40 backdrop-blur-md rounded-2xl overflow-hidden border border-white/10 z-50">
                  <video autoPlay muted playsInline ref={(v) => { if(v) v.srcObject = videoRef.current?.srcObject; }} className="w-full h-full object-cover scale-x-[-1]" />
                </div>
              )}
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
